<!DOCTYPE html>
<html lang="de">
<head>
<meta charset="UTF-8" />
<title>Mini Minecraft Terrain</title>
<style>
  body { margin:0; overflow:hidden; background:#87CEEB; }
  canvas { display:block; margin:0 auto; background:#87CEEB; }
</style>
</head>
<body>
<canvas id="game" width="800" height="450"></canvas>
<script>
// --- Konfiguration ---
const BLOCK_SIZE = 32; // Pixelgröße eines Blocks
const CHUNK_SIZE = 16; // Blöcke pro Chunk (Quadratisch)
const GRAVITY = 0.5;
const JUMP_VELOCITY = -10;
const MOVE_SPEED = 4;
const WORLD_HEIGHT = 64; // Welt-Höhe in Blöcken

// Canvas Setup
const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');

// Spieler
const player = {
  x: BLOCK_SIZE * 8, // Pixel-Koordinaten
  y: BLOCK_SIZE * 10,
  width: BLOCK_SIZE * 0.8,
  height: BLOCK_SIZE * 1.6,
  velX: 0,
  velY: 0,
  onGround: false
};

// Steuerung
const keys = {
  left: false,
  right: false,
  up: false
};

// Welt-Daten: Map von chunkX zu Chunk-Arrays
// Jeder Chunk ist ein 2D Array [y][x] mit Blöcken
// Block 0 = Luft, 1 = Erde
const worldChunks = new Map();

// Hilfsfunktion: Pseudo-Perlin / Simplex artige Höhe für Terrain
function terrainHeight(x) {
  // Einfaches Sinus + Rauschen
  return Math.floor(20 + 5 * Math.sin(x * 0.3) + (Math.sin(x * 0.7)*3));
}

// Generiere einen Chunk bei chunkX
function generateChunk(chunkX) {
  if(worldChunks.has(chunkX)) return; // Chunk schon da

  const chunk = [];
  for(let y=0; y < WORLD_HEIGHT; y++) {
    chunk[y] = [];
    for(let x=0; x < CHUNK_SIZE; x++) {
      // Globale x Position
      const globalX = chunkX * CHUNK_SIZE + x;
      const height = terrainHeight(globalX);

      // Blöcke unter Höhe sind Erde, darüber Luft
      if(y >= WORLD_HEIGHT - height) chunk[y][x] = 1;
      else chunk[y][x] = 0;
    }
  }
  worldChunks.set(chunkX, chunk);
}

// Chunk-Ladebereich (aktiver Bereich um Spieler)
const RENDER_DISTANCE = 3; // Anzahl Chunks links/rechts

// Gibt Block an Weltposition zurück
function getBlockAt(globalX, globalY) {
  if(globalY < 0 || globalY >= WORLD_HEIGHT) return 0; // Luft außerhalb Welt

  const chunkX = Math.floor(globalX / CHUNK_SIZE);
  generateChunk(chunkX);
  const chunk = worldChunks.get(chunkX);
  const localX = globalX % CHUNK_SIZE;
  if(localX < 0) return 0;

  return chunk[globalY][localX];
}

// Setzt Block an Weltposition (globalX/globalY) auf neuen Wert
function setBlockAt(globalX, globalY, value) {
  if(globalY < 0 || globalY >= WORLD_HEIGHT) return; 
  const chunkX = Math.floor(globalX / CHUNK_SIZE);
  generateChunk(chunkX);
  const chunk = worldChunks.get(chunkX);
  const localX = globalX % CHUNK_SIZE;
  if(localX < 0) return;
  chunk[globalY][localX] = value;
}

// Kollisionsabfrage für Spieler mit der Welt
function checkCollision(x, y, width, height) {
  // Prüfe alle Blöcke, die das Rechteck berührt
  const startX = Math.floor(x / BLOCK_SIZE);
  const endX = Math.floor((x + width) / BLOCK_SIZE);
  const startY = Math.floor(y / BLOCK_SIZE);
  const endY = Math.floor((y + height) / BLOCK_SIZE);

  for(let by = startY; by <= endY; by++) {
    for(let bx = startX; bx <= endX; bx++) {
      if(getBlockAt(bx, by) !== 0) return true;
    }
  }
  return false;
}

// Spielschleife
function update() {
  // Bewegung
  if(keys.left) player.velX = -MOVE_SPEED;
  else if(keys.right) player.velX = MOVE_SPEED;
  else player.velX = 0;

  // Springen
  if(keys.up && player.onGround) {
    player.velY = JUMP_VELOCITY;
    player.onGround = false;
  }

  // Gravitation
  player.velY += GRAVITY;
  if(player.velY > 12) player.velY = 12; // Terminal Velocity

  // Neue Position voraussagen
  let newX = player.x + player.velX;
  let newY = player.y + player.velY;

  // X-Kollision
  if(!checkCollision(newX, player.y, player.width, player.height)) {
    player.x = newX;
  } else {
    player.velX = 0;
  }

  // Y-Kollision
  if(!checkCollision(player.x, newY, player.width, player.height)) {
    player.y = newY;
    player.onGround = false;
  } else {
    // Wenn nach unten kollidiert: auf Boden gesetzt
    if(player.velY > 0) {
      player.onGround = true;
    }
    player.velY = 0;
  }

  render();
  requestAnimationFrame(update);
}

// Zeichne Blöcke und Spieler
function render() {
  ctx.clearRect(0,0,canvas.width,canvas.height);

  // Kamera zentriert auf Spieler (Pixel)
  const camX = player.x + player.width/2 - canvas.width/2;
  const camY = player.y + player.height/2 - canvas.height/2;

  // Lade alle nötigen Chunks (links/rechts)
  const playerChunkX = Math.floor((player.x + player.width/2) / (CHUNK_SIZE * BLOCK_SIZE));

  for(let cx = playerChunkX - RENDER_DISTANCE; cx <= playerChunkX + RENDER_DISTANCE; cx++) {
    generateChunk(cx);
  }

  // Zeichne Blöcke
  for(let cx = playerChunkX - RENDER_DISTANCE; cx <= playerChunkX + RENDER_DISTANCE; cx++) {
    const chunk = worldChunks.get(cx);
    if(!chunk) continue;

    for(let y=0; y < WORLD_HEIGHT; y++) {
      for(let x=0; x < CHUNK_SIZE; x++) {
        if(chunk[y][x] !== 0) {
          const globalX = cx * CHUNK_SIZE + x;
          const px = globalX * BLOCK_SIZE - camX;
          const py = y * BLOCK_SIZE - camY;
          // Nur Blöcke sichtbar zeichnen, die im Canvas sind
          if(px + BLOCK_SIZE < 0 || px > canvas.width || py + BLOCK_SIZE < 0 || py > canvas.height) continue;

          // Erde: braun
          ctx.fillStyle = '#654321';
          ctx.fillRect(px, py, BLOCK_SIZE, BLOCK_SIZE);
          // Block-Rand
          ctx.strokeStyle = '#4B2E05';
          ctx.strokeRect(px, py, BLOCK_SIZE, BLOCK_SIZE);
        }
      }
    }
  }

  // Spieler zeichnen (rot)
  const playerPx = player.x - camX;
  const playerPy = player.y - camY;
  ctx.fillStyle = '#FF0000';
  ctx.fillRect(playerPx, playerPy, player.width, player.height);
}

// Steuerung
window.addEventListener('keydown', e => {
  if(e.code === 'KeyA') keys.left = true;
  if(e.code === 'KeyD') keys.right = true;
  if(e.code === 'Space') keys.up = true;
});

window.addEventListener('keyup', e => {
  if(e.code === 'KeyA') keys.left = false;
  if(e.code === 'KeyD') keys.right = false;
  if(e.code === 'Space') keys.up = false;
});

// Blöcke abbauen / platzieren mit Maus
canvas.addEventListener('mousedown', e => {
  // Mausposition relativ zu Canvas
  const rect = canvas.getBoundingClientRect();
  const mouseX = e.clientX - rect.left;
  const mouseY = e.clientY - rect.top;

  // Kamera wie im Render berechnen
  const camX = player.x + player.width/2 - canvas.width/2;
  const camY = player.y + player.height/2 - canvas.height/2;

  // Weltkoordinaten des angeklickten Blocks
  const worldX = Math.floor((mouseX + camX) / BLOCK_SIZE);
  const worldY = Math.floor((mouseY + camY) / BLOCK_SIZE);

  // Abstand vom Spieler zum Block (für Range limit)
  const distX = (worldX + 0.5)*BLOCK_SIZE - (player.x + player.width/2);
  const distY = (worldY + 0.5)*BLOCK_SIZE - (player.y + player.height/2);
  const dist = Math.sqrt(distX*distX + distY*distY);
  if(dist > BLOCK_SIZE*6) return; // Max Reichweite 6 Blöcke

  if(e.button === 0) {
    // Linksklick: Block abbauen (ersetzen mit Luft)
    if(getBlockAt(worldX, worldY) !== 0) {
      setBlockAt(worldX, worldY, 0);
    }
  } else if(e.button === 2) {
    // Rechtsklick: Block platzieren (Erde), wenn leer
    if(getBlockAt(worldX, worldY) === 0) {
      setBlockAt(worldX, worldY, 1);
    }
  }
});

// Rechtsklick Kontextmenü verhindern
canvas.addEventListener('contextmenu', e => e.preventDefault());

// Start Spiel
update();
</script>
</body>
</html>
