<!DOCTYPE html>
<html lang="de">
<head>
<meta charset="UTF-8" />
<title>Mini 3D Minecraft WebGL</title>
<style>
  body, html { margin:0; height:100%; overflow:hidden; background: #87ceeb; }
  canvas { display: block; }
  #instructions {
    position: absolute; top: 10px; left: 10px; color: white; font-family: monospace;
    background: rgba(0,0,0,0.5); padding: 10px; border-radius: 5px;
    user-select:none;
  }
</style>
</head>
<body>
<div id="instructions">
  Klick zum starten (Pointer Lock)<br>
  WASD: bewegen, Maus: schauen, Leertaste: springen<br>
  Linksklick: Block abbauen, Rechtsklick: Block setzen
</div>
<canvas id="glcanvas"></canvas>
<script>

// --- Setup WebGL ---
const canvas = document.getElementById('glcanvas');
canvas.width = window.innerWidth;
canvas.height = window.innerHeight;
const gl = canvas.getContext('webgl');
if(!gl) alert('WebGL wird nicht unterstützt!');

// --- Shader-Quellen ---
const vsSource = `
attribute vec3 aPosition;
attribute vec3 aColor;

uniform mat4 uProjectionMatrix;
uniform mat4 uViewMatrix;
uniform mat4 uModelMatrix;

varying vec3 vColor;

void main() {
  gl_Position = uProjectionMatrix * uViewMatrix * uModelMatrix * vec4(aPosition, 1.0);
  vColor = aColor;
}
`;

const fsSource = `
precision mediump float;

varying vec3 vColor;

void main() {
  gl_FragColor = vec4(vColor, 1.0);
}
`;

// --- Shader kompilieren ---
function createShader(type, source) {
  const shader = gl.createShader(type);
  gl.shaderSource(shader, source);
  gl.compileShader(shader);
  if(!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
    alert("Shader Fehler: " + gl.getShaderInfoLog(shader));
    gl.deleteShader(shader);
    return null;
  }
  return shader;
}

function createProgram(vsSrc, fsSrc) {
  const vs = createShader(gl.VERTEX_SHADER, vsSrc);
  const fs = createShader(gl.FRAGMENT_SHADER, fsSrc);
  const program = gl.createProgram();
  gl.attachShader(program, vs);
  gl.attachShader(program, fs);
  gl.linkProgram(program);
  if(!gl.getProgramParameter(program, gl.LINK_STATUS)) {
    alert("Programm Fehler: " + gl.getProgramInfoLog(program));
    return null;
  }
  return program;
}

const program = createProgram(vsSource, fsSource);
gl.useProgram(program);

// --- Attribute / Uniform Standorte ---
const attribPosition = gl.getAttribLocation(program, "aPosition");
const attribColor = gl.getAttribLocation(program, "aColor");
const uniformProjection = gl.getUniformLocation(program, "uProjectionMatrix");
const uniformView = gl.getUniformLocation(program, "uViewMatrix");
const uniformModel = gl.getUniformLocation(program, "uModelMatrix");

// --- Würfel-Daten (Position + Farbe pro Eckpunkt) ---

const cubePositions = new Float32Array([
  // Front face (Rötlich)
  0,0,1,  1,0,1,  1,1,1,  0,1,1,
  // Back face (Grünlich)
  0,0,0,  1,0,0,  1,1,0,  0,1,0
]);

// Farben je Ecke (einfach je Seite eigene Farbe, 8 Ecken)
const cubeColors = new Float32Array([
  // Front rot (rot)
  1,0,0, 1,0,0, 1,0,0, 1,0,0,
  // Back grün (grün)
  0,1,0, 0,1,0, 0,1,0, 0,1,0
]);

// Indizes (36 für 12 Dreiecke)
const cubeIndices = new Uint16Array([
  // Front
  0,1,2,  0,2,3,
  // Back
  5,4,7,  5,7,6,
  // Left
  4,0,3,  4,3,7,
  // Right
  1,5,6,  1,6,2,
  // Top
  3,2,6,  3,6,7,
  // Bottom
  4,5,1,  4,1,0
]);

// --- Buffer Setup ---
const posBuffer = gl.createBuffer();
gl.bindBuffer(gl.ARRAY_BUFFER, posBuffer);
gl.bufferData(gl.ARRAY_BUFFER, cubePositions, gl.STATIC_DRAW);

const colorBuffer = gl.createBuffer();
gl.bindBuffer(gl.ARRAY_BUFFER, colorBuffer);
gl.bufferData(gl.ARRAY_BUFFER, cubeColors, gl.STATIC_DRAW);

const indexBuffer = gl.createBuffer();
gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);
gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, cubeIndices, gl.STATIC_DRAW);

// --- Mathefunktionen für Mat4 ---

function createProjectionMatrix(fov, aspect, near, far) {
  const f = 1.0 / Math.tan(fov / 2);
  const nf = 1 / (near - far);
  const out = new Float32Array(16);
  out[0] = f / aspect;
  out[5] = f;
  out[10] = (far + near) * nf;
  out[11] = -1;
  out[14] = (2 * far * near) * nf;
  return out;
}

function createViewMatrix(eye, center, up) {
  const f = normalize(subtract(center, eye));
  const s = normalize(cross(f, up));
  const u = cross(s, f);

  const out = new Float32Array(16);
  out[0] = s[0]; out[4] = s[1]; out[8]  = s[2];  out[12] = -dot(s, eye);
  out[1] = u[0]; out[5] = u[1]; out[9]  = u[2];  out[13] = -dot(u, eye);
  out[2] = -f[0];out[6] = -f[1];out[10] = -f[2]; out[14] = dot(f, eye);
  out[3] = 0;    out[7] = 0;    out[11] = 0;     out[15] = 1;
  return out;
}

function dot(a,b) {
  return a[0]*b[0]+a[1]*b[1]+a[2]*b[2];
}

function normalize(v) {
  const len = Math.sqrt(dot(v,v));
  return [v[0]/len, v[1]/len, v[2]/len];
}

function cross(a,b) {
  return [
    a[1]*b[2]-a[2]*b[1],
    a[2]*b[0]-a[0]*b[2],
    a[0]*b[1]-a[1]*b[0]
  ];
}

function subtract(a,b) {
  return [a[0]-b[0], a[1]-b[1], a[2]-b[2]];
}

function createIdentity() {
  const out = new Float32Array(16);
  out[0]=1; out[5]=1; out[10]=1; out[15]=1;
  return out;
}

function translate(m, v) {
  const out = new Float32Array(m);
  out[12] += v[0];
  out[13] += v[1];
  out[14] += v[2];
  return out;
}

// --- Spieler/Kamera ---
const player = {
  pos: [8,6,8],
  rot: [0, 0], // pitch, yaw
  velocity: [0,0,0],
  canJump: false
};
let keys = {};

// --- Pointer Lock ---
canvas.onclick = () => {
  canvas.requestPointerLock();
};

document.addEventListener('pointerlockchange', () => {
  if(document.pointerLockElement === canvas) {
    document.addEventListener('mousemove', onMouseMove);
  } else {
    document.removeEventListener('mousemove', onMouseMove);
  }
});

function onMouseMove(e) {
  const sensitivity = 0.0025;
  player.rot[1] -= e.movementX * sensitivity;
  player.rot[0] -= e.movementY * sensitivity;
  if(player.rot[0] > Math.PI/2) player.rot[0] = Math.PI/2;
  if(player.rot[0] < -Math.PI/2) player.rot[0] = -Math.PI/2;
}

// --- Tastatur ---
document.addEventListener('keydown', e => {
  keys[e.code] = true;
  if(e.code === 'Space' && player.canJump) {
    player.velocity[1] = 7;
    player.canJump = false;
  }
});
document.addEventListener('keyup', e => {
  keys[e.code] = false;
});

// --- Weltdaten ---

const WORLD_SIZE = 16;
const WORLD_HEIGHT = 16;

const world = new Uint8Array(WORLD_SIZE * WORLD_HEIGHT * WORLD_SIZE);

function getIndex(x,y,z) {
  return y*WORLD_SIZE*WORLD_SIZE + z*WORLD_SIZE + x;
}

function getBlock(x,y,z) {
  if(x<0||x>=WORLD_SIZE||y<0||y>=WORLD_HEIGHT||z<0||z>=WORLD_SIZE) return 0;
  return world[getIndex(x,y,z)];
}

function setBlock(x,y,z,v) {
  if(x<0||x>=WORLD_SIZE||y<0||y>=WORLD_HEIGHT||z<0||z>=WORLD_SIZE) return;
  world[getIndex(x,y,z)] = v;
}

// Terrain generieren (einfach: Boden bis y=4)
for(let x=0; x<WORLD_SIZE; x++) {
  for(let z=0; z<WORLD_SIZE; z++) {
    const h = 4 + Math.floor(2*Math.sin(x*0.5) + 2*Math.cos(z*0.5));
    for(let y=0; y<=h; y++) {
      setBlock(x,y,z,1);
    }
  }
}

// --- Input Funktionen ---

function getForwardVector() {
  return [
    Math.cos(player.rot[0]) * Math.sin(player.rot[1]),
    Math.sin(player.rot[0]),
    Math.cos(player.rot[0]) * Math.cos(player.rot[1])
  ];
}

function getRightVector() {
  return [
    Math.sin(player.rot[1] - Math.PI/2),
    0,
    Math.cos(player.rot[1] - Math.PI/2)
  ];
}

// --- Raycast für Blockauswahl ---
function raycast(maxDist=8) {
  let pos = player.pos.slice();
  const dir = getForwardVector();

  for(let i=0; i<maxDist*10; i++) {
    pos[0] += dir[0]*0.1;
    pos[1] += dir[1]*0.1;
    pos[2] += dir[2]*0.1;

    const bx = Math.floor(pos[0]);
    const by = Math.floor(pos[1]);
    const bz = Math.floor(pos[2]);

    if(getBlock(bx,by,bz) != 0) {
      return {x:bx, y:by, z:bz};
    }
  }
  return null;
}

// --- Blöcke abbauen/setzen ---
canvas.addEventListener('mousedown', e => {
  if(document.pointerLockElement !== canvas) return;
  e.preventDefault();

  const hit = raycast();
  if(!hit) return;

  if(e.button === 0) {
    // Linksklick: Block abbauen
    setBlock(hit.x, hit.y, hit.z, 0);
  } else if(e.button === 2) {
    // Rechtsklick: Block setzen in angrenzendem Feld (einfach oberhalb)
    setBlock(hit.x, hit.y+1, hit.z, 1);
  }
});
canvas.addEventListener('contextmenu', e => e.preventDefault());

// --- Rendering Funktion ---

function drawCube(modelMatrix) {
  gl.uniformMatrix4fv(uniformModel, false, modelMatrix);

  gl.bindBuffer(gl.ARRAY_BUFFER, posBuffer);
  gl.enableVertexAttribArray(attribPosition);
  gl.vertexAttribPointer(attribPosition, 3, gl.FLOAT, false, 0, 0);

  gl.bindBuffer(gl.ARRAY_BUFFER, colorBuffer);
  gl.enableVertexAttribArray(attribColor);
  gl.vertexAttribPointer(attribColor, 3, gl.FLOAT, false, 0, 0);

  gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);

  gl.drawElements(gl.TRIANGLES, cubeIndices.length, gl.UNSIGNED_SHORT, 0);
}

// --- Spiel-Update ---

function updatePlayer(delta) {
  const speed = 5;
  const gravity = -20;

  // Bewegung in x/z
  let moveX = 0;
  let moveZ = 0;
  if(keys['KeyW']) moveZ += 1;
  if(keys['KeyS']) moveZ -= 1;
  if(keys['KeyA']) moveX -= 1;
  if(keys['KeyD']) moveX += 1;

  // Normalisieren (diagonal gleich schnell)
  const len = Math.sqrt(moveX*moveX + moveZ*moveZ);
  if(len>0) {
    moveX /= len;
    moveZ /= len;
  }

  const forward = getForwardVector();
  const right = getRightVector();

  player.velocity[0] = moveX * speed;
  player.velocity[2] = moveZ * speed;

  // Bewegungsrichtung zur Welt transformieren (nur x,z)
  player.pos[0] += (right[0]*moveX + forward[0]*moveZ)*speed*delta;
  player.pos[2] += (right[2]*moveX + forward[2]*moveZ)*speed*delta;

  // Gravitation & springen
  player.velocity[1] += gravity * delta;
  player.pos[1] += player.velocity[1] * delta;

  // Kollisionscheck Boden
  const footX = Math.floor(player.pos[0]);
  const footY = Math.floor(player.pos[1]);
  const footZ = Math.floor(player.pos[2]);

  if(getBlock(footX, footY-1, footZ) != 0) {
    player.pos[1] = footY;
    player.velocity[1] = 0;
    player.canJump = true;
  }
}

// --- Render Loop ---
const projectionMatrix = createProjectionMatrix(Math.PI/4, canvas.width/canvas.height, 0.1, 100);
function render(time=0) {
  time /= 1000;
  const delta = Math.min(time - (render.lastTime || 0), 0.1);
  render.lastTime = time;

  updatePlayer(delta);

  gl.viewport(0,0,canvas.width,canvas.height);
  gl.clearColor(0.53, 0.81, 0.92, 1); // Himmelblau
  gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
  gl.enable(gl.DEPTH_TEST);

  // Viewmatrix aus Position & Rotation
  const pitch = player.rot[0];
  const yaw = player.rot[1];

  const eye = player.pos;
  const center = [
    eye[0] + Math.cos(pitch)*Math.sin(yaw),
    eye[1] + Math.sin(pitch),
    eye[2] + Math.cos(pitch)*Math.cos(yaw)
  ];
  const up = [0,1,0];

  const viewMatrix = createViewMatrix(eye, center, up);

  gl.uniformMatrix4fv(uniformProjection, false, projectionMatrix);
  gl.uniformMatrix4fv(uniformView, false, viewMatrix);

  // Terrain Blöcke rendern (alle, die nicht 0 sind)
  for(let x=0; x<WORLD_SIZE; x++) {
    for(let y=0; y<WORLD_HEIGHT; y++) {
      for(let z=0; z<WORLD_SIZE; z++) {
        if(getBlock(x,y,z) != 0) {
          const model = translate(createIdentity(), [x,y,z]);
          drawCube(model);
        }
      }
    }
  }

  requestAnimationFrame(render);
}
requestAnimationFrame(render);

</script>
</body>
</html>
