<!DOCTYPE html>
<html lang="de">
<head>
<meta charset="UTF-8" />
<title>Mini 3D Minecraft in reinem WebGL</title>
<style>
  body { margin: 0; overflow: hidden; }
  canvas { display: block; }
  #instructions {
    position: absolute; top: 10px; left: 10px; color: white; font-family: monospace;
    background: rgba(0,0,0,0.5); padding: 10px; border-radius: 5px;
  }
</style>
</head>
<body>
<div id="instructions">
  Klick zum Starten & Pointer Lock<br>
  WASD: Bewegen, Maus: Blick<br>
  Leertaste: Springen<br>
  Linksklick: Block abbauen<br>
  Rechtsklick: Block platzieren (in Blickrichtung)
</div>
<canvas id="glcanvas"></canvas>

<script>
// --- Globals ---

const canvas = document.getElementById('glcanvas');
canvas.width = window.innerWidth;
canvas.height = window.innerHeight;

const gl = canvas.getContext('webgl');
if (!gl) {
  alert('WebGL wird nicht unterstützt');
}

// --- Shader Quellen ---

const vsSource = `
  attribute vec3 aPosition;
  uniform mat4 uProjectionMatrix;
  uniform mat4 uViewMatrix;
  uniform mat4 uModelMatrix;
  void main(void) {
    gl_Position = uProjectionMatrix * uViewMatrix * uModelMatrix * vec4(aPosition, 1.0);
  }
`;

const fsSource = `
  precision mediump float;
  uniform vec4 uColor;
  void main(void) {
    gl_FragColor = uColor;
  }
`;

// --- Shader erstellen und kompilieren ---
function loadShader(type, source) {
  const shader = gl.createShader(type);
  gl.shaderSource(shader, source);
  gl.compileShader(shader);
  if(!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
    alert('Shader Fehler: ' + gl.getShaderInfoLog(shader));
    gl.deleteShader(shader);
    return null;
  }
  return shader;
}

function initShaderProgram(vsSrc, fsSrc) {
  const vertexShader = loadShader(gl.VERTEX_SHADER, vsSrc);
  const fragmentShader = loadShader(gl.FRAGMENT_SHADER, fsSrc);
  const shaderProgram = gl.createProgram();
  gl.attachShader(shaderProgram, vertexShader);
  gl.attachShader(shaderProgram, fragmentShader);
  gl.linkProgram(shaderProgram);
  if(!gl.getProgramParameter(shaderProgram, gl.LINK_STATUS)) {
    alert('Shader Programm Fehler: ' + gl.getProgramInfoLog(shaderProgram));
    return null;
  }
  return shaderProgram;
}

const shaderProgram = initShaderProgram(vsSource, fsSource);

const programInfo = {
  program: shaderProgram,
  attribLocations: {
    vertexPosition: gl.getAttribLocation(shaderProgram, 'aPosition'),
  },
  uniformLocations: {
    projectionMatrix: gl.getUniformLocation(shaderProgram, 'uProjectionMatrix'),
    viewMatrix: gl.getUniformLocation(shaderProgram, 'uViewMatrix'),
    modelMatrix: gl.getUniformLocation(shaderProgram, 'uModelMatrix'),
    color: gl.getUniformLocation(shaderProgram, 'uColor'),
  }
};

// --- Würfel Geometrie (8 Eckpunkte, 36 Indizes) ---

const cubeVertices = new Float32Array([
  // Front face
  0,0,1,
  1,0,1,
  1,1,1,
  0,1,1,
  // Back face
  0,0,0,
  1,0,0,
  1,1,0,
  0,1,0,
]);

const cubeIndices = new Uint16Array([
  0,1,2, 0,2,3,       // Front
  5,4,7, 5,7,6,       // Back
  4,0,3, 4,3,7,       // Left
  1,5,6, 1,6,2,       // Right
  3,2,6, 3,6,7,       // Top
  4,5,1, 4,1,0        // Bottom
]);

// --- Buffer Setup ---

const positionBuffer = gl.createBuffer();
gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
gl.bufferData(gl.ARRAY_BUFFER, cubeVertices, gl.STATIC_DRAW);

const indexBuffer = gl.createBuffer();
gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);
gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, cubeIndices, gl.STATIC_DRAW);

// --- Perspektivmatrix ---
function perspective(fovy, aspect, near, far) {
  const f = 1.0 / Math.tan(fovy / 2);
  const nf = 1 / (near - far);
  const out = new Float32Array(16);
  out[0] = f / aspect;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;

  out[4] = 0;
  out[5] = f;
  out[6] = 0;
  out[7] = 0;

  out[8] = 0;
  out[9] = 0;
  out[10] = (far + near) * nf;
  out[11] = -1;

  out[12] = 0;
  out[13] = 0;
  out[14] = (2 * far * near) * nf;
  out[15] = 0;
  return out;
}

// --- Mat4 LookAt Matrix ---

function normalize(v) {
  const len = Math.sqrt(v[0]*v[0]+v[1]*v[1]+v[2]*v[2]);
  return [v[0]/len, v[1]/len, v[2]/len];
}

function cross(a,b) {
  return [
    a[1]*b[2]-a[2]*b[1],
    a[2]*b[0]-a[0]*b[2],
    a[0]*b[1]-a[1]*b[0]
  ];
}

function subtract(a,b) {
  return [a[0]-b[0], a[1]-b[1], a[2]-b[2]];
}

function lookAt(eye, center, up) {
  const f = normalize(subtract(center, eye));
  const s = normalize(cross(f, up));
  const u = cross(s, f);

  const out = new Float32Array(16);
  out[0] = s[0];
  out[1] = u[0];
  out[2] = -f[0];
  out[3] = 0;

  out[4] = s[1];
  out[5] = u[1];
  out[6] = -f[1];
  out[7] = 0;

  out[8] = s[2];
  out[9] = u[2];
  out[10] = -f[2];
  out[11] = 0;

  out[12] = - (s[0]*eye[0] + s[1]*eye[1] + s[2]*eye[2]);
  out[13] = - (u[0]*eye[0] + u[1]*eye[1] + u[2]*eye[2]);
  out[14] = (f[0]*eye[0] + f[1]*eye[1] + f[2]*eye[2]);
  out[15] = 1;

  return out;
}

// --- Mat4 Translation ---
function translate(m, v) {
  const out = new Float32Array(m);
  out[12] += v[0];
  out[13] += v[1];
  out[14] += v[2];
  return out;
}

// --- Mat4 Skalierung ---
function scale(m, v) {
  const out = new Float32Array(16);
  for(let i=0; i<16; i++) out[i] = m[i];
  out[0] *= v[0];
  out[5] *= v[1];
  out[10]*= v[2];
  return out;
}

// --- Kamera & Spieler ---
const player = {
  pos: [8, 5, 8],
  rot: [0, 0], // pitch, yaw
  velocity: [0,0,0],
  canJump: false
};

let keys = {};

// --- Pointer Lock & Maus Bewegung ---
canvas.requestPointerLock = canvas.requestPointerLock || canvas.mozRequestPointerLock;

document.exitPointerLock = document.exitPointerLock || document.mozExitPointerLock;

canvas.onclick = () => {
  canvas.requestPointerLock();
};

document.addEventListener('pointerlockchange', lockChange, false);
document.addEventListener('mozpointerlockchange', lockChange, false);

function lockChange() {
  if(document.pointerLockElement === canvas || document.mozPointerLockElement === canvas) {
    document.addEventListener("mousemove", onMouseMove, false);
  } else {
    document.removeEventListener("mousemove", onMouseMove, false);
  }
}

function onMouseMove(e) {
  const sensitivity = 0.002;
  player.rot[1] -= e.movementX * sensitivity; // yaw
  player.rot[0] -= e.movementY * sensitivity; // pitch
  if(player.rot[0] < -Math.PI/2) player.rot[0] = -Math.PI/2;
  if(player.rot[0] > Math.PI/2) player.rot[0] = Math.PI/2;
}

// --- Key Events ---
document.addEventListener('keydown', e => {
  keys[e.code] = true;
  if(e.code === "Space" && player.canJump) {
    player.velocity[1] = 8;
    player.canJump = false;
  }
});

document.addEventListener('keyup', e => {
  keys[e.code] = false;
});

// --- Terrain Daten ---

const WORLD_SIZE = 16; // 16x16 Blöcke flach
const WORLD_HEIGHT = 16;

const world = new Uint8Array(WORLD_SIZE*WORLD_HEIGHT*WORLD_SIZE);

// Terrain generieren (einfach Hügel mit Sinus)
for(let x=0; x<WORLD_SIZE; x++) {
  for(let z=0; z<WORLD_SIZE; z++) {
    const height = Math.floor(5 + 3 * Math.sin(x * 0.5) + 3 * Math.cos(z * 0.5));
    for(let y=0; y<=height; y++) {
      setBlock(x,y,z,1);
    }
  }
}

function setBlock(x,y,z,val) {
  if(x<0||x>=WORLD_SIZE||y<0||y>=WORLD_HEIGHT||z<0||z>=WORLD_SIZE) return;
  world[y*WORLD_SIZE*WORLD_SIZE + z*WORLD_SIZE + x] = val;
}

function getBlock(x,y,z) {
  if(x<0||x>=WORLD_SIZE||y<0||y>=WORLD_HEIGHT||z<0||z>=WORLD_SIZE) return 0;
  return world[y*WORLD_SIZE*WORLD_SIZE + z*WORLD_SIZE + x];
}

// --- Rendering Würfel Funktion ---

function renderCube(x,y,z)
