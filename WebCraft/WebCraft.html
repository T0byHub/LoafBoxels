<!DOCTYPE html>
<html lang="de">
<head>
<meta charset="UTF-8" />
<title>WebCraft (ohne Three.js)</title>
<style>
  body, html {
    margin:0; overflow:hidden; background:#000; user-select:none;
    font-family: monospace, monospace;
  }
  #crosshair {
    position: fixed;
    top: 50%;
    left: 50%;
    width: 15px;
    height: 15px;
    margin-left: -7.5px;
    margin-top: -7.5px;
    pointer-events: none;
    z-index: 10;
  }
  canvas {
    display: block;
    background: #87CEEB; /* Himmelblau */
  }
</style>
</head>
<body>
<img id="crosshair" src="https://i.imgur.com/cUZZYyW.png" alt="Crosshair" />
<canvas id="game"></canvas>
<script>
(() => {
  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d');
  let W, H;

  function resize() {
    W = window.innerWidth;
    H = window.innerHeight;
    canvas.width = W;
    canvas.height = H;
  }
  resize();
  window.addEventListener('resize', resize);

  // Einfaches Terrain (16x16 Blöcke flach)
  const terrainSize = 16;
  const blockSize = 40; // Pixel auf 2D-Canvas
  const blocks = [];
  for(let x=0; x<terrainSize; x++){
    for(let z=0; z<terrainSize; z++){
      blocks.push({x, y:0, z});
    }
  }

  // Spielerposition und Blickrichtung (nur 2D seitlich)
  let player = {x:8, y:2, z:8, dir:0}; // dir in Grad, 0 = Richtung +z

  // Steuerung
  const keys = {};
  window.addEventListener('keydown', e => keys[e.key.toLowerCase()] = true);
  window.addEventListener('keyup', e => keys[e.key.toLowerCase()] = false);

  // Textur laden (grass)
  const grass = new Image();
  grass.src = 'https://i.imgur.com/2D6bgZg.png';

  // 3D-Projektion (ganz simpel)
  function project(x,y,z){
    const fov = 200;
    const scale = fov / (z - player.z + 5);
    return {
      x: (x - player.x) * scale + W/2,
      y: H/2 - (y - player.y) * scale,
      scale
    };
  }

  // Blöcke zeichnen (als einfache Rechtecke, perspektivisch skaliert)
  function drawBlock(x,y,z){
    const p = project(x,y,z);
    if(p.scale <= 0) return; // nicht sichtbar

    const size = blockSize * p.scale;
    ctx.drawImage(grass, 0, 0, 16, 16, p.x - size/2, p.y - size, size, size);
    // ein einfacher Block-Umriss
    ctx.strokeStyle = 'black';
    ctx.strokeRect(p.x - size/2, p.y - size, size, size);
  }

  // Haupt-Loop
  function loop(){
    ctx.clearRect(0,0,W,H);

    // Bewegung
    const speed = 0.1;
    if(keys['w']) {
      player.x += Math.sin(player.dir * Math.PI/180) * speed;
      player.z += Math.cos(player.dir * Math.PI/180) * speed;
    }
    if(keys['s']) {
      player.x -= Math.sin(player.dir * Math.PI/180) * speed;
      player.z -= Math.cos(player.dir * Math.PI/180) * speed;
    }
    if(keys['a']) player.dir -= 2;
    if(keys['d']) player.dir += 2;

    // Blöcke zeichnen, von hinten nach vorne (Z sortiert)
    blocks.sort((a,b) => (b.z - player.z) - (a.z - player.z));
    for(const b of blocks){
      drawBlock(b.x,b.y,b.z);
    }

    requestAnimationFrame(loop);
  }
  loop();

  // Klicks: Linksabbau, Rechtsbau (einfach block vor Spieler)
  canvas.addEventListener('mousedown', e => {
    e.preventDefault();
    // Block direkt vor Spieler
    const frontX = Math.floor(player.x + Math.sin(player.dir * Math.PI/180));
    const frontZ = Math.floor(player.z + Math.cos(player.dir * Math.PI/180));
    const frontY = 0;
    const idx = blocks.findIndex(b => b.x === frontX && b.y === frontY && b.z === frontZ);
    if(e.button === 0){
      if(idx !== -1) blocks.splice(idx,1);
    }
    else if(e.button === 2){
      if(idx === -1) blocks.push({x:frontX,y:frontY,z:frontZ});
    }
  });
  canvas.addEventListener('contextmenu', e => e.preventDefault());
})();
</script>
</body>
</html>
