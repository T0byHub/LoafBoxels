<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>MiniCraft 3D</title>
  <style>
    body { margin: 0; overflow: hidden; }
    canvas { display: block; }
  </style>
  <script src="https://cdn.jsdelivr.net/npm/three@0.158.0/build/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/simplex-noise@3.0.0/dist/esm/simplex-noise.min.js" type="module"></script>
</head>
<body>
  <canvas id="gameCanvas"></canvas>
  <script type="module">
    import { SimplexNoise } from 'https://cdn.jsdelivr.net/npm/simplex-noise@3.0.0/+esm';

    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x87ceeb); // Himmelblau

    const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    const renderer = new THREE.WebGLRenderer({ canvas: document.getElementById('gameCanvas') });
    renderer.setSize(window.innerWidth, window.innerHeight);

    // Licht
    const light = new THREE.DirectionalLight(0xffffff, 1);
    light.position.set(1, 1, 0.5).normalize();
    scene.add(light);

    const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
    scene.add(ambientLight);

    // Terrain
    const blockSize = 1;
    const terrainSize = 20;
    const blocks = {};
    const simplex = new SimplexNoise();

    function addBlock(x, y, z) {
      const geometry = new THREE.BoxGeometry(blockSize, blockSize, blockSize);
      const material = new THREE.MeshStandardMaterial({ color: 0x55aa55 });
      const cube = new THREE.Mesh(geometry, material);
      cube.position.set(x, y, z);
      scene.add(cube);
      blocks[`${x},${y},${z}`] = cube;
    }

    function removeBlock(x, y, z) {
      const key = `${x},${y},${z}`;
      const block = blocks[key];
      if (block) {
        scene.remove(block);
        delete blocks[key];
      }
    }

    // Terrain generieren
    for (let x = -terrainSize; x <= terrainSize; x++) {
      for (let z = -terrainSize; z <= terrainSize; z++) {
        const y = Math.floor(simplex.noise2D(x / 10, z / 10) * 3) - 2;
        addBlock(x, y, z);
      }
    }

    // Spieler
    camera.position.set(0, 5, 5);

    const keys = {};
    document.addEventListener('keydown', e => keys[e.key.toLowerCase()] = true);
    document.addEventListener('keyup', e => keys[e.key.toLowerCase()] = false);

    let velocityY = 0;
    const gravity = -0.02;
    let isOnGround = false;

    const raycaster = new THREE.Raycaster();
    const mouse = new THREE.Vector2();

    document.addEventListener('click', e => {
      mouse.x = (e.clientX / window.innerWidth) * 2 - 1;
      mouse.y = -(e.clientY / window.innerHeight) * 2 + 1;
      raycaster.setFromCamera(mouse, camera);
      const intersects = raycaster.intersectObjects(Object.values(blocks));
      if (intersects.length > 0) {
        const pos = intersects[0].object.position;
        if (e.shiftKey) {
          removeBlock(pos.x, pos.y, pos.z);
        } else {
          const normal = intersects[0].face.normal;
          const newPos = pos.clone().add(normal);
          addBlock(Math.round(newPos.x), Math.round(newPos.y), Math.round(newPos.z));
        }
      }
    });

    function animate() {
      requestAnimationFrame(animate);

      // Bewegung
      const speed = 0.1;
      const dir = new THREE.Vector3();
      if (keys['w']) dir.z -= 1;
      if (keys['s']) dir.z += 1;
      if (keys['a']) dir.x -= 1;
      if (keys['d']) dir.x += 1;
      dir.normalize();
      const move = dir.applyAxisAngle(new THREE.Vector3(0, 1, 0), camera.rotation.y).multiplyScalar(speed);
      camera.position.add(move);

      // Gravitation
      velocityY += gravity;
      camera.position.y += velocityY;

      const cx = Math.floor(camera.position.x);
      const cz = Math.floor(camera.position.z);
      const belowY = Math.floor(camera.position.y - 1.7);
      const groundBlock = blocks[`${cx},${belowY},${cz}`];

      if (groundBlock) {
        isOnGround = true;
        velocityY = 0;
        camera.position.y = belowY + 1.8;
      } else {
        isOnGround = false;
      }

      if (keys[' '] && isOnGround) {
        velocityY = 0.4;
      }

      camera.lookAt(camera.position.x, camera.position.y - 1, camera.position.z - 5);
      renderer.render(scene, camera);
    }

    animate();
  </script>
</body>
</html>
